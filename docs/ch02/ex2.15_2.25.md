##Exercise 2.15>Which of the following definitions, if any, are invalid? Why?- (a) int ival = 1.01;- (b) int &rval1 = 1.01;- (c) int &rval2 = ival;- (d) int &rval3;```(a): valid.(b): invalid. initializer must be an object.(c): valid.(d): invalid. a reference must be initialized.```##Exercise 2.16>Which, if any, of the following assignments are invalid? If they are valid, explain what they do.    int i = 0, &r1 = i; double d = 0, &r2 = d;- (a) r2 = 3.14159;- (b) r2 = r1;- (c) i = r2;- (d) r1 = d;```(a): valid. let d equal 3.14159.(b): invalid. r1 must be a double object.(c): valid. but value will be truncated.(d): valid. but value will be truncated.```##Exercise 2.17>What does the following code print?```cppint i, &ri = i;i = 5; ri = 10;std::cout << i << " " << ri << std::endl;````10, 10`##Exercise 2.18>Write code to change the value of a pointer. Write code tochange the value to which the pointer points.```cppint a = 0, b = 1;int *p1 = &a, *p2 = p1;// change the value of a pointer.p1 = &b;// change the value to which the pointer points*p2 = b;```##Exercise 2.19>Explain the key differences between pointers and references.####definition:the pointer is "points to" anyother type.the reference is "another name" of an **object**.####key difference:1. a reference is another name of an **already existing** object.a pointer is an object in its **own right**.2. Once initialized, a reference remains **bound to** its initial object.There is **no way** to rebind a reference to refer to a different object.a pointer can be **assigned** and **copied**.3. a reference always get the object to which the reference was intially bound.a single pointer can point to **several different objects** over its lifetime.4. a reference must be initialized.a pointer need **not be** initialized at the time it is defined.####Usage advise:Look at [here](http://www.parashift.com/c%2B%2B-faq-lite/refs-vs-ptrs.html)##Exercise 2.20>What does the following program do?```cppint i = 42;int *p1 = &i; *p1 = *p1 * *p1;````p1` pointer to `i`, `i`'s value changed to 1764(42*42)##Exercise 2.21>Explain each of the following definitions. Indicate whether any are illegal and, if so, why.    int i = 0;- (a) double* dp = &i;- (b) int *ip = i;- (c) int *p = &i;```(a): illegal, cannot initialize a variable of type 'double *' with an      rvalue of type 'int *'(b): illegal, cannot initialize a variable of type 'int *' with an lvalue      of type 'int'(c): legal.```##Exercise 2.22Assuming p is a pointer to int, explain the following code:```cppif (p) // ...if (*p) // ...```if (p) // whether p is nullptr?if (*p) // whether the value pointed by p is zero?##Exercise 2.23>Given a pointer p, can you determine whether p points to a valid object? If so, how? If not, why not?```cppif (p)  // p points to a valid objectelse  // p points to a invalid object```##Exercise 2.24>Why is the initialization of p legal but that of lp illegal?```cppint i =42;void *p=&i;long *lp=&i;```Because the type `void*` is a special pointer type that can hold the address of any object.But we cannot initialize a variable of type `long *` with an rvalue of type `int *`##Exercise 2.25>Determine the types and values of each of the followingvariables.- (a) int* ip, &r = ip;- (b) int i, *ip = 0;- (c) int* ip, ip2;```(a): ip is a pointer to int, r is a reference to the pointer ip.(b): ip is a valid, null pointer.(c): ip is a pointer to int, and ip2 is a int.```